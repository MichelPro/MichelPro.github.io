<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Kotlin成为Android开发官方语言]]></title>
    <url>%2F2017%2F05%2F18%2FKotlin%E6%88%90%E4%B8%BAAndroid%E5%BC%80%E5%8F%91%E5%AE%98%E6%96%B9%E8%AF%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[一夜之间，Kotlin大火 早上一觉醒来，发现Kotlin群里讨论的热火朝天，打开一看发现来了很多新人。原来就在2017年5月18日 Google I/O 2017开发者大会上发生了这么一件大事： 谷歌宣布 Kotlin 编程语言成为 Android 编程的首选语言。谷歌称还将与 JetBrains 公司合作，为 Kotlin 设立一个非盈利基金会。JetBrains 在 2010 年首次推出 Kotlin 编程语言，并在次年将其开源。下一版的 Android Studio（3.0）也将支持 Kotlin。 作为一个野生的菜鸟级Kotlin开发人员而言，总有种媳妇熬成婆的感觉！Kotlin终于被Google承认了！以后再也不用战战兢兢的使用Kotlin了！项目中也可以大范围使用Kotlin了！这难道不激动么？就连Kotlin的官方网站首页介绍也大方的说自己是“Android官方语言”了 那么，什么是Kotlin呢？ 作为还是一个菜鸟级的Kotlin学习人员，实在不敢在各位面前对Kotlin大谈特谈。了解Kotlin最好还是去Kotlin官方网站去看一下最为科学。另外，Google也为Kotlin开辟了专门的版块，有意思的是，Google在这个页面附图容易让人误解，到底，是Kotlin抱住Android呢，还是Android抱住Kotlin呢？滑稽脸~ Kotlin有啥好处？忘记当时为啥接触Kotlin了，只记得当时最吸引我的有两点： Kotlin不需要写分号 Kotlin能大幅度减少空指针异常 就因为这两点，纯真的我一不小心就入了Kotlin的坑，再也没爬出来过！ 什么？这两点不算吸引人？要知道，我这里说的，只是Kotlin最明显的两个特征而已，你可以尝试去了解了解Kotlin，我想，你也会疯狂的爱上并使用Kotlin的！ 这个博文水到这里结束！我只是耐不住激动的心情来发个博文抒发一下Kotlin转正的激动的心情而已~ 我要继续写Kotlin去了 推荐阅读Benny应该是我的Kotlin启蒙老师，也算是国内最早了解Kotlin的人之一吧，既然聊到了Kotlin，我也忍不住把他的博客地址放在最后推荐给想学Kotlin或者对Kotlin有那么一丝兴趣的人。]]></content>
      <categories>
        <category>新闻资讯</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手把手教你如何将你的Library发布到JCenter]]></title>
    <url>%2F2017%2F04%2F27%2F%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%A6%82%E4%BD%95%E5%B0%86%E4%BD%A0%E7%9A%84Library%E5%8F%91%E5%B8%83%E5%88%B0JCenter-Maven%2F</url>
    <content type="text"><![CDATA[前言在依赖别人的项目的时候，是不是特别羡慕一行就可以依赖别人的库？没事，你的库也可以的。这次Michel就手把手教你如何将你的Library发布到JCenter上。 在动手之前，我们要明确一些概念，这里以compile &#39;com.squareup.picasso:picasso:2.5.2&#39;为例： 其中：com.squareup.picasso为GROUP_ID，picasso为ARTIFACT_ID，2.5.2为 VERSION_ID。知道了这三者，对于之后创建共享库的时候就有了一定的计划性了。 动手第一部分：在bintray上创建自己的package 在https://bintray.com/ 上注册账号，注册过程不再赘述。很简单。 注册成功后，点击Add New Repository，添加你的maven库。 在创建的时候要注意：name和type都要填写/选择maven，否则后期通过cmd上传的时候会报Could not create package HTTP/1.1 401 Unauthorized [message:This resource requires authentication]这样的错误。 创建maven库成功之后，点击进入这个maven库，选择Add New Package 填写必要的信息： 这里要注意，虽然如何命名没有什么限定，但是也有一定的规范。所有的字母应该是小写，单词之间用“-”分割，比如“android-lib”。 这里的name建议使用你未来的ARTIFACT_ID。 Licenses是协议，要选择Apache-2.0。 Tags没有什么要求，接下来的Website、Issues tracker和Version control就是你这个库的GitHub地址、Issues和版本控制。 所有的填写完成后，就可以选择create package。 创建完成后，会直接进入edit界面，这时候我们选择我们的package名字，就进入package详情。 恭喜，现在在bintray上已经有了自己的库了! 目前来看，bintray的一些基本配置完成了。接下来就要准备我们的library了。 第二部分：准备一个Android Studio项目 创建library 一般来讲，我们需要准备两个module，一个就是你的library，另一个就是展示如何使用你的library。 如何新建library，这里就不在赘述，只是放一个创建完成的截图：这里要注意，你的library module的名字要和你的package的名字保持一致，否则后期上传到bintray的时候，会出现两个不同的文件。 修改project中的build.gradle： 在buildscript下的dependencies下，添加如下两句： 12classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.6'classpath 'com.github.dcendents:android-maven-gradle-plugin:1.4.1' 创建的时候默认会有个gradle，如果你的gradle版本低于1.1.2，请将其修改为这之上。 接下来我们将修改local.properties。 在里面定义api key的用户名以及被创建key的密码，用于bintray的认证。之所以要把这些东西放在这个文件是因为这些信息时比较敏感的，不应该到处分享，包括版本控制里面。幸运的是在创建项目的时候local.properties文件就已经被添加到.gitignore了。因此这些敏感数据不会被误传到git服务器。 下面是要添加的代码： 12bintray.user=xxxxxxxbintray.apikey=xxxxxxxxxxxxxxxxxxx 然后修改Library的build.gradle: 1234567891011121314151617181920212223242526272829apply plugin: 'com.android.library'ext &#123; bintrayRepo = 'maven' // 这里默认就好 bintrayName = 'android-lib' // 这里就写你的library也就是packageName最好 publishedGroupId = 'com.michel' // 这里是你的GroupId libraryName = 'AndroidLib' artifact = 'android-lib' // 此处随意 libraryDescription = 'Android Library' // 这里是你要共享库的GitHub地址 siteUrl = 'https://github.com/MichelPro/AndroidLib' gitUrl = 'https://github.com/MichelPro/AndroidLib.git' // 这就是library的版本号，每次发布新版的时候要修改版本号 libraryVersion = '0.0.3' // 这里随意，个人信息 developerId = 'michel' developerName = 'MichelPro' developerEmail = 'MichelProLei@gmail.com' // 这就是协议内容了，不要修改 licenseName = 'The Apache Software License, Version 2.0' licenseUrl = 'http://www.apache.org/licenses/LICENSE-2.0.txt' allLicenses = ["Apache-2.0"]&#125; 为了方便管理，上面其实是配置列表，我们通过创建另外两个gradle去设置具体实现。 这里提供两个方法，如果你们嫌麻烦，直接可以在自己的library的build.gradle最后添加： 12apply from: 'https://raw.githubusercontent.com/MichelPro/AndroidLib/master/install.gradle'apply from: 'https://raw.githubusercontent.com/MichelPro/AndroidLib/master/java-bintray.gradle' 添加完成后sync一下就可以了。这一步完成~ 对于一些想把什么都握在自己手中的人来说，也可以选择依赖本地的文件（毕竟我也不知道什么时候我就跑路了~） 在Project下分别创建install.gradle和java-bintray.gradle这两个gradle文件， install.gradle文件内容： 123456789101112131415161718192021222324252627282930313233343536373839404142apply plugin: 'com.github.dcendents.android-maven'group = publishedGroupId // Maven Group ID for the artifactinstall &#123; repositories.mavenInstaller &#123; // This generates POM.xml with proper parameters pom &#123; project &#123; packaging 'aar' groupId publishedGroupId artifactId artifact // Add your description here name libraryName description libraryDescription url siteUrl // Set your license licenses &#123; license &#123; name licenseName url licenseUrl &#125; &#125; developers &#123; developer &#123; id developerId name developerName email developerEmail &#125; &#125; scm &#123; connection gitUrl developerConnection gitUrl url siteUrl &#125; &#125; &#125; &#125;&#125; java-bintray.gradle文件内容： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859apply plugin: 'com.jfrog.bintray'version = libraryVersionif (project.hasProperty("android")) &#123; // Android libraries task sourcesJar(type: Jar) &#123; classifier = 'sources' from android.sourceSets.main.java.srcDirs &#125; task javadoc(type: Javadoc) &#123; source = android.sourceSets.main.java.srcDirs classpath += project.files(android.getBootClasspath().join(File.pathSeparator)) &#125;&#125; else &#123; // Java libraries task sourcesJar(type: Jar, dependsOn: classes) &#123; classifier = 'sources' from sourceSets.main.allSource &#125;&#125;task javadocJar(type: Jar, dependsOn: javadoc) &#123; classifier = 'javadoc' from javadoc.destinationDir&#125;artifacts &#123; archives javadocJar archives sourcesJar&#125;// BintrayProperties properties = new Properties()properties.load(project.rootProject.file('local.properties').newDataInputStream())bintray &#123; user = properties.getProperty("bintray.user") key = properties.getProperty("bintray.apikey") configurations = ['archives'] pkg &#123; repo = bintrayRepo name = bintrayName desc = libraryDescription websiteUrl = siteUrl vcsUrl = gitUrl licenses = allLicenses publish = true publicDownloadNumbers = true version &#123; desc = libraryDescription gpg &#123; sign = true //Determines whether to GPG sign the files. The default is false passphrase = properties.getProperty("bintray.gpg.password") //Optional. The passphrase for GPG signing' &#125; &#125; &#125;&#125; 然后再在library的build.gradle文件最后进行依赖： 12apply from: '../install.gradle'apply from: '../java-bintray.gradle' 简单吧！就这样！你本地库的一些操作暂且告一段落~ 第三部分：把library上传到你的bintray空间 打开你的Terminal，检查代码的正确性，以及编译library文件（aar，pom等等），输入下面的命令： 如果没有什么问题，会显示： 1BUILD SUCCESSFUL 现在我们已经成功一半了。下一步是上传编译的文件到bintray，使用如下的命令： 1gradlew bintrayUpload 如果显示如下你就大喊一声eureka吧！ 1SUCCESSFUL 在bintray的网页上检查一下你的package。你会发现在版本区域的变化 是不是已经有了最新版？就是你之前写的libraryVersion？！别激动让我们看一下我们的files选项卡！ 如果选择进去除了版本文件夹之外，只有一个文件夹，并且最后的界面javadoc和sources等文件一个不少，那就说明这一步没毛病！ 第四部分：同步bintray用户仓库到jcenter此时，我们打开我们的package的详情页，选择Add to JCenter 什么都不需要输入（如果你想写点啥也行），选择send，接下来就是静等2~3个小时（也许会更长），你的邮箱里就会发现有了回复！ 审核通过后，之前的空白处就会变成这样： 从此之后，任何开发者都可以使用jcenter() repository 外加一行gradle脚本来使用我们的library了！ 想检查一下自己的library在jcenter上是否存在？你可以直接访问http://jcenter.bintray.com ，然后进入和你library的group id 以及artifact id匹配的目录。在本例中就是com -&gt; michel -&gt; android-lib -&gt; 0.0.7。 请注意链接到jcenter是一个只需做一次的操作。如果你对你的package做了任何修改，比如上传了一个新版本的binary，删除了旧版本的binary等等，这些改变也会影响到jcenter。不过毕竟你自己的仓库和jcenter在不同的地方，所以需要等待2－3分钟让jcenter同步这些修改。 同时注意，如果你决定删除整个package，放在jcenter仓库上的library不会被删除。它们会像僵尸一样的存在，没有人再能删除它了。因此我建议，如果你想删除整个package，请在移除package之前先在网页上删除每一个版本。 后记在第一次上传的时候也是经历过很多坑，但是耐下性子，多百度和Google，很多问题，其实都不是问题。 这个教程也是根据前人的经验写的，只是比别人的教程多了一些细节而已，毕竟经过了一些的综合，我想，还是能满足大部分人的需求的。 只是这个文章只是说了如何发布到JCenter上，关于上传到Maven的方法我就没有写在这里了，如果你有这方面的需求，还是自己去找一些资料吧。]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin项目发布到Maven/JCenter库]]></title>
    <url>%2F2017%2F04%2F26%2FKotlin%E4%B8%8A%E4%BC%A0%E5%88%B0Jcenter%2F</url>
    <content type="text"><![CDATA[本文前提是已经有了自己的Maven/JCenter库，对于如何将自己的库发布到Maven/JCenter，本文在此不再赘述。 满心欢喜，发布失败之前说过，最近在研究Kotlin，于是将自己的库部分代码换成Kotlin语言，没想到在发布到bintray的时候，控制台竟然报错： 1javadoc: 错误 -非法的程序包名称：“....kt” 这时候有点无奈啊，javadoc竟然报错，还不能删，………………，否则jcenter审核不通过……………… 百度不行，Google救场Kejin很好的解释了如何解决问题。未完待续。]]></content>
      <categories>
        <category>技术博文</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本以为是data class 的锅，没想到是FastJson的锅]]></title>
    <url>%2F2017%2F03%2F14%2FKotlin%E4%B9%8BData%20class%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[正文最近迷上了Kotlin，正在逐步将项目中的Java代码部分替代成Kotlin实现，但是一个个删除重写岂不是太麻烦？还好AndroidStudio有这么一个工具：Convert Java File to Kotlin File，通过名字我们就知道，这是将Java文件一键转换成Kotlin文件的工具。 初步转换按捺住激动的心情，从项目中的JavaBean入手开始转起！咻！~~ 但是发现转换过来的代码一点都不优雅：1234class User&#123; var id: String? = null var name: String? = null&#125; 有默认值的data class这样子算什么嘛！一点KotlinStyle都没有！既然Kotlin中有data class这个东东，我们怎么可以放过它？来！我们删删删！改改改！于是乎……1234data class User( var id: String? = null var name: String? = null) 嗯，由于是在项目上动刀，当然要run一下啦！发现这样写并没有什么不妥。看起来还行！是不是！？ 正常data class的写法但是我感觉并不是这样啊！我强迫症啊！这样写你可以让参数是null 啊！而且还必须要赋初值！！看起来简直丑到爆！于是我就手贱删掉了！它就变成这个样子：1234data class User( var id: String, var name: String) 这样才好看？是不是？（鬼知道我什么审美）。然后！让我们红尘作伴，run的潇潇洒洒！WTF？！崩了！1com.alibaba.fastjson.JSONException: default constructor not found 报错很直白嘛！就是告诉你没有默认的构造函数！这不就X了狗了么（放开狗！让你来！） 注：其实在这里呢，你可以直接将FastJson换成Gson了。 noArg（这里其实是解决反射获取无参构造失败的解决方案）据说是少一个noArg的东西，按照教程，我们首先在自己Project的gradle添加如下配置：12345678buildscript &#123;... dependencies &#123; ... classpath "org.jetbrains.kotlin:kotlin-noarg:$kotlin_version" ... &#125;&#125; 然后我们去自己的module里创建一个注解类（Kotlin的），放在哪、命名都随你，反正我是命名为PoKo1annotation class PoKo 紧接着我们回到之前的gradle文件中，继续添加配置：12345apply plugin: "kotlin-noarg" noArg &#123; annotation("com.your.Annotation") // 注意！这里是你的注解的全路径！也就是我的Poko的全路径&#125; 最后我们返回到最初的data class，在前面加上你的注解！1234@PoKo data class User( var id: String, var name: String) 这次的我信心满满！没毛病了吧！Run！ 打脸事实告诉我！不要轻易立Flag！ 同样的Error又来了一遍！WTF？我都快怀疑人生了好吧！后来才发现原来是FastJson的锅！FastJson并不是通过反射去获取无参构造。这个noArg的解决方案主要是针对orm和spring那种通过反射去获取无参构造失败的解决方案。 至于json解析？还是换成Google的亲儿子Gson吧。而且使用Gson的话，你也不必去使用这个注解。因为Gson比较流氓。他在解析对象的时候，先去找无参构造，找不到就用 Unsafe.allocateInstance 来创建对象，主要这个创建方法非常的底层，你可以简单的理解为只为实例化出来的 Java 对象开辟了对象存续需要的空间，而对应地它的成员没有一个会正常初始化。 而我？我知道我要把项目中的FastJson换成Gson去！再也不相信阿里爸爸了！ 好了，如果你用Gson，你什么都不用做。如果你用FastJson，那你就赋初值吧！如果嫌麻烦？学我！全面换成Gson！ 啰啰嗦嗦终于写完了，废话比较多！随意看看吧。 结语爬坑的过程中主要参照了Benny的博客才解决，如果想对这个问题有更深入的理解，可以直接访问Benny的博客。我也是因为Benny才入的Kotlin的坑！希望Kotlin能越来越火！]]></content>
      <categories>
        <category>技术博文</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重新设计Android项目结构]]></title>
    <url>%2F2017%2F01%2F27%2F%E9%87%8D%E6%96%B0%E8%AE%BE%E8%AE%A1Android%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[一团糟的项目结构也许是因为赶进度，也许是因为各种原因，我们有时候无脑cv一通，项目很快就完成了上线。然后你回头看你的项目结构是这样的： 123456com.michel |--activity |--fragment |--utils |--adapter ………… 乍一看还是可以的，最起码基本做到了分门别类的放置。但是也许你的Activity包里已经有了近百个Activity了，这时候如果上面经过开会决定某一部分的业务流程进行修改，那你还能准确定位到所有相关类么？而且由于前期没有经过任何设计，你的代码其实已经是一坨一坨的了，牵一发而动全身，动一下都可能导致到处都会崩溃。 这时候你就不得不进行项目重构了，一个好的项目结构设计，能够很好的应对后期需求的各种调整。这里Michel就简单跟你说说相对优化的项目结构是怎样的。 重新规划Android项目结构第一步：建立AndroidLib类库之前所有的东西我们都放在了一个module里，非常混乱而且不易于维护。我们要做的，是将与业务无关的逻辑转移到AndroidLib中，最后让我们的app通过Gradle依赖AndroidLib即可。 那么，AndroidLib中应该包括什么呢？ 我认为最起码包括以下几点： base 这个包下主要存放的是BaseActivity、BaseFragment、BaseAdapter等基类，但是这些基类中封装的是业务无关的公用逻辑，主项目中可以再次封装一些业务相关的公用逻辑。 ui 这里没什么好说的，当然是我们的自定义控件。 common common是一个通用型的工具箱集，它可以对上层所依赖的第三方框架做解耦操作。如何理解这句话呢？ 假如我们要解析json，我们肯定不会重复造轮子。解析JSON的框架就有很多，比如Ali的FastJSON，Google的Gson等。 在没有common时，项目1.0使用了FastJSON进行json的数据解析，但是项目2.0时，FastJSON存在某些BUG，你需要将FastJSON替换成Gson。但是由于你到处使用到了FastJSON，你无法做到只是改一行代码就能让所有的json解析都换成Gson。 这时common的威力就显现出来了。我们将json解析库进行二次封装，项目中调用common，common调用第三方依赖，如果更换第三方库，我们只需要在common中进行调整即可。 这只是个例子，网络请求、图片加载等我们都可以这样做进行解耦。 最终我们的AndroidLib包结构大概是这样的： 12345678AndroidLib |--src |--main |--java |--com.michel |--base |--ui |--common 当然，如果你有更好的想法当然可以进行自我调整。 第二步：重新设计主项目的包说完了基础类库，我们再来说说主项目。 其实我们之前所展示的主项目的结构也差不多，在这里我们只需要在此基础上进行一些微调即可1234567com.michel |--activity // 这里可以按照业务模块进行继续拆分 |--fragment |--utils |--adapter |--entity // 所有的实体 |--base // 与业务相关的BaseActivity等，继承AndroidLib中的BaseActivity 以上就是主项目结构的微调，其实和最初没有太大的改变，主要是我们将业务无关的公用逻辑以及第三方库进行解耦抽取到了AndroidLib中，虽然结构表面看起来没有多大改善，实际应用中你会发现比之前简直好了太多。]]></content>
      <categories>
        <category>技术博文</category>
      </categories>
      <tags>
        <tag>Re</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手把手教你用Hexo搭建Blog]]></title>
    <url>%2F2016%2F09%2F26%2F%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E7%94%A8Hexo%E6%90%AD%E5%BB%BABlog%2F</url>
    <content type="text"><![CDATA[出问题多问百度和Google，本教程是针对于windows用户所写。 搭建本地环境准备工具工欲善其事必先利其器，我们首先要准备好两款软件node.js和git 这里安装配置暂且略过。 创建本地文件打开Git Bash，接下来的命令输入都是在Git Bash中进行 安装hexo：1$ npm install hexo-cli -g 正常会显示如下： 如果遇到了以下的错误：1ERROR Deployer not found : github 则直接运行以下命令，也可以直接运行以下命令：1$ npm install hexo-deployer-git –save 找到你想存放本地博客的位置（建议直接在盘符的根目录下直接创建hexo文件夹），比如我就是在F:\hexo文件中存放我的个人博客 进入这个文件夹，右键-&gt;Git Bash here 然后在这里执行：1$ hexo init 这个时间可能比较长，执行过程中有warn也不用管，执行完毕之后，安装依赖包：1$ npm install 安装完成后，F:\hexo 文件目录是这样的 本地测试执行完上述命令之后，其实博客已经生成。我们可以在本地预览下：1$ hexo server 然后我们用浏览器访问：http://localhost:4000/ 就可以看到效果了。 如果要停止hexo服务，在Git Bash下按Ctrl + C即可 关于hexo的命令 解释可以直接看官网 自定义主题讨厌了默认的模样？hexo也是提供主题的。我们可以到 hexo的主题网站 知乎-有哪些好看的 Hexo 主题？ hexo-github-theme-list中找你喜欢的主题，按照教程一步步进行设置。 我这里选择的是比较简洁的nexT主题。官网 也是有集成介绍的，包括一些扩展用法，我就不多说了。 链接github仓库注册github账号已有github账号跳过此步。如果没有则进入github注册，想好用户名，因为这关乎到你之后的博客地址（当然，用户名也是可以改的） 创建仓库-New repository这里注意，在创建的时候 repository name的第一个前缀必须要和你的github用户名一致，我在创建的时候填写的是michelpro。后两个前缀必须是github.io。填写完成之后就可以选择create repository，创建仓库了。 链接本地和github创建SSH秘钥，鼠标右键任意地方，打开Git Bash，输入以下命令：1$ ssh-keygen -t rsa -C "你的github的邮箱地址" 然后三次回车，最后生成效果如图： 这时候，打开C:\Users\你的pc用户名.ssh就可以看到生成的私钥和公钥 其中: id_rsa是私钥 id_rsa.pub是公钥。 如果生成的不是这样的文件，则删除掉重新输入命令再次执行。 添加SSH到github用记事本的打开方式打开 id_rsa.pub 文件，全选复制全部内容，注意你可以看到文件内容是以ssh-rsa开头，你的邮箱地址结尾的。 然后打开你的github设置 ，选择New SSH key，添加SSH Title可以随便，将刚才id_rsa.pub文件中的内容复制到Key的输入框内，选择Add SSH key，尾巴不要有空行留着，要注意看。 把本地的博客同步到github上如果想将本地的静态博客同步到github，我们好需要先安装相关的hexo插件：在Git Bash中输入:（如果你之前执行了该命令则不必理会）1$ npm install hexo-deployer-git –save 然后编辑hexo的站点配置文件：_config.yml 对于每一个参数是什么意思，官网 有明确的说明 主要是最后一部分：1234deploy: type: git repo: git@github.com:MichelPro/MichelPro.github.io.git // 这里将MichelPro换成你的github名即可 branch: master 编辑完成后，我们重新生成静态文件:1$ hexo g 然后生成完成之后，我们再本地预览一下:1$ hexo s –debug 预览没毛病，那么就发布到github吧:1$ hexo d 这时候进入你的github服务器地址就可以看到你之前生成的静态页了。一般来讲，我们发布时只需要：1$ hexo d -g 这样的组合命令进行发布最为方便。 使用Intellij写博客下载安装Intellij作为一个Android的bug创造人员，AS是我常用的工具。而AS就是基于Intellij开发的，这里对于如何使用Intellij就不多说了，你只要知道Intellij很强大就好了 使用Intellij使用Intellij打开你的hexo文件夹，打开后效果如图： 由于Intellij在Windows下默认的终端是cmd，而我们常用的是Git Bash，所以我们要修改Intellij的设置。 打开Intellij的设置 找到Tools-&gt;Terminal下的Shell path选项，默认是指向的你的cmd.exe，修改为指向你的git目录下的bash.exe 选择ok保存之后，这时候打开Intellij下方的Terminal窗口，就会变成我们熟悉的界面： 以后我们就可以直接在这里进行新建、调试、发布等一系列操作了。 哦，对了，记得给你的Intellij安装MarkDown插件：二选一就行 自定义域名（更新于2017年5月19日）注册购买域名国内的知名域名购买网站有阿里爸爸的万网、腾讯爸爸的腾讯云 等网站。你可以分别在这两个网站进行域名搜索，然后比对下哪家便宜在哪家购买~滑稽脸~ 域名的注册和购买就不多说了，网站会一步一步引导你往下进行的。 链接github地址我是在腾讯云购买的域名，打开你的【管理中心】，进入【域名管理】，记得进行实名认证哦。然后选择“解析” 在这里为你的域名添加解析记录，其中192.30.252.153和192.30.252.154是github官方ip地址，记录类型均为A，主机记录均为@ ，线路类型选择默认就行；然后再添加一条记录类型为CNAME，主机记录是www，线路类型依然默认，但是记录值是你的github博客地址。最终如下： 到这里还没有结束，你要去你的hexo/source文件夹下，新增一个不带任何后缀的CNAME文件，在这个文件中写入你的域名 最后在控制台输入1$ hexo d -g 提交到github上，待你域名实名认证通过，你就可以通过域名访问你的博客了~再也不用输入一大串github地址了！]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>